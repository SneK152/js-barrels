#!/usr/bin/env node
import { readdirSync, readFileSync, writeFileSync } from "fs";
import { join } from "path";
import yargs from "yargs";
import watch from "node-watch";
import chalk from "chalk";

const argv = yargs
  .options({
    dir: {
      alias: "d",
      demandOption: true,
      type: "string",
      description: "Directory to generate barrels for",
    },
    watch: {
      alias: "w",
      type: "boolean",
      description: "Watch and make barrels recursively",
    },
  })
  .parseSync();

function joinPath(...path: string[]) {
  return join(process.cwd(), ...path);
}

function makeBarrels(watch: boolean) {
  const dirFiles = readdirSync(joinPath(argv.dir));
  const extension = dirFiles.join(",").includes(".ts") ? "ts" : "js";
  const comments = `// AUTO GENERATED BY JS-BARRELS`;

  if (dirFiles.includes(`index.${extension}`)) {
    const fileContents = readFileSync(
      joinPath(argv.dir, dirFiles.find((f) => f === `index.${extension}`)!)
    ).toString();
    if (!fileContents.startsWith(comments)) {
      console.log(
        chalk.bgRed("\n ERROR "),
        chalk.red(
          "Directory already contains an index file not generated by js-barrels."
        )
      );
      process.exit();
    }
  }

  type Export = {
    default: boolean;
    name: string;
    fileName: string;
  };

  const e: Export[] = [];

  for (const file of dirFiles) {
    const fileContents = readFileSync(joinPath(argv.dir, file)).toString();
    if (fileContents.includes("export") && !file.includes("index")) {
      let stringToSearch = "export default";

      if (fileContents.includes(stringToSearch)) {
        const contents = fileContents
          .substring(fileContents.indexOf(stringToSearch), fileContents.length)
          .split("\n")[0];

        const filteredContents = contents.substring(
          stringToSearch.length + 1,
          contents.length
        );

        if (
          filteredContents.startsWith("function") ||
          filteredContents.startsWith("interface")
        ) {
          let keyword = filteredContents.startsWith("function")
            ? "function"
            : "interface";

          const id = filteredContents.substring(
            keyword.length + 1,
            filteredContents.length
          );

          const token =
            keyword === "function"
              ? id.substring(0, id.indexOf("("))
              : id.substring(0, id.indexOf(" "));

          e.push({
            default: true,
            name: token,
            fileName: `./${file.split(".")[0]}`,
          });
        }
      } else {
        e.push({
          default: false,
          name: "",
          fileName: `./${file.split(".")[0]}`,
        });
      }
    }
  }

  const generatedFile = `${comments}
${e
  .map((ex) =>
    ex.default
      ? `export { default as ${ex.name} } from "${ex.fileName}";`
      : `export * from "${ex.fileName}";`
  )
  .join("\n")}`;
  writeFileSync(joinPath(argv.dir, `index.${extension}`), generatedFile);
  if (watch) {
    console.log(
      chalk.bgYellow(" FILE SAVED "),
      chalk.yellow("Barrel files regenerated.")
    );
  } else {
    console.log(
      "\n" + chalk.bgGreen(" SUCCESS "),
      chalk.green("Barrel files generated.\n")
    );
  }
}

if (argv.watch) {
  makeBarrels(false);
  watch(
    argv.dir,
    {
      recursive: false,
      filter: (f) => !f.includes("index.ts") && !f.includes("index.js"),
    },
    () => {
      makeBarrels(true);
    }
  );
} else {
  makeBarrels(false);
}
